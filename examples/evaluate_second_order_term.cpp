/**
 * This file is a part of channelflow version 2.0 https://channelflow.ch.
 * License is GNU GPL version 2 or later: ./LICENCE
 */
#include <sys/stat.h>
#include <Eigen/Dense>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <string>
#include "cfbasics/cfvector.h"
#include "channelflow/cfdsi.h"
#include "channelflow/chebyshev.h"
#include "channelflow/dns.h"
#include "nsolver/gmres.h"
#include "channelflow/flowfield.h"
#include "channelflow/symmetry.h"
#include "channelflow/tausolver.h"
#include "nsolver/nsolver.h"
#include "channelflow/diffops.h" // because of readheteroclinicorbit
#include "channelflow/poissonsolver.h"
using namespace std;
using namespace Eigen;
using namespace chflow;

int main(int argc, char* argv[]) {
    cfMPI_Init(&argc, &argv);
    {
        WriteProcessInfo(argc, argv);
        int taskid = 0;
#ifdef HAVE_MPI
        MPI_Comm_rank(MPI_COMM_WORLD, &taskid);
#endif

        string purpose(
            "Solve the linear equation defining the second order term: (A-2lambda)x = (w_1 grad) w_1 ");
        ArgList args(argc, argv, purpose);

        DNSFlags dnsflags(args);
        TimeStep dt(dnsflags);
        dnsflags.verbosity = Silent;


        args.section("Program options");
        const string sigstr =
            args.getstr("-sigma", "--sigma", "", "file containing sigma of sigma f^T(u) - u = 0 (default == identity)");

        const int seed = args.getint("-sd", "--seed", 1, "seed for random number generator");
        const Real lambda = args.getreal("-lambda", "--lambda", 0, "Eigenvalue");
        const Real epsKrylov = args.getreal("-ek", "--epsKrylov", 1e-14, "minimum condition number of Krylov vectors");
        const Real epsSolver = args.getreal("-eg", "--epsSolver", 1e-3, "stop GMRES iteration when Ax = b residual is < epsSolver");

        const int nproc0 =
            args.getint("-np0", "--nproc0", 0, "number of MPI-processes for transpose/number of parallel ffts");
        const int nproc1 = args.getint("-np1", "--nproc1", 0, "number of MPI-processes for one fft");
        //const int length = args.getint("-nst", "--numsnapshots", 0, "number of snapshots along the heteroclinic orbit");
        //const int DTS = args.getint("-dst", "--distsnapshots", 0, "sampling rate of snapshots");

        const string source_in = args.getstr(1, "<src>", "eigenvector: w1");
        const string source_lb = args.getstr(2, "<src>", "LB ");
        const int NSolver = args.getint("-Ng", "--Ngmres", 500, "maximum number of GMRES iterations");

        //const string source_out = args.getstr(3, "<src2>", "Location of the output file");
        
        CfMPI* cfmpi = &CfMPI::getInstance(nproc0, nproc1);
        args.check();
        args.save("./");

        fftw_loadwisdom();

        srand48(seed);

        // read LB: 
        
        FlowField LB(source_lb, cfmpi);  // u*, the solution of sigma f^T(u*) - u* = 0
        FlowField w1(source_in, cfmpi); 

        const int Nx = LB.Nx();
        const int Ny = LB.Ny();
        const int Nz = LB.Nz();

        const int kxmin = -LB.kxmaxDealiased();
        const int kxmax = LB.kxmaxDealiased();
        const int kzmin = 0;
        const int kzmax = LB.kzmaxDealiased();

        if (taskid == 0) {
            cout << setprecision(17);
            cout << "   Nx == " << Nx << endl;
            cout << "   Ny == " << Ny << endl;
            cout << "   Nz == " << Nz << endl;
            cout << "kxmin == " << kxmin << endl;
            cout << "kxmax == " << kxmax << endl;
            cout << "kzmin == " << kzmin << endl;
            cout << "kzmax == " << kzmax << endl;

            cout << "dt     == " << dt.dt() << endl;
            cout << "dtmin  == " << dt.dtmin() << endl;
            cout << "dtmax  == " << dt.dtmax() << endl;
            cout << "CFLmin == " << dt.CFLmin() << endl;
            cout << "CFLmax == " << dt.CFLmax() << endl;
        }
        dt.adjust_for_T(dnsflags.T);

        FieldSymmetry sigma;  // defaults to identity
        if (sigstr.length() != 0)
            sigma = FieldSymmetry(sigstr);

        if (dnsflags.symmetries.length() > 0) {
            if (taskid == 0) {
                cout << "Restricting flow to invariant subspace generated by symmetries" << endl;
                cout << dnsflags.symmetries << endl;
            }
        }

        if (taskid == 0)
            cout << "DNS flags = " << dnsflags << endl;



        // Set up DNS operator ("A" in Arnoldi A*b terms)
        if (taskid == 0)
            cout << "setting up DNS and initial fields..." << endl;
        ChebyTransform trans(Ny);

        
        if (taskid == 0)
            cout << "computing sigma f^T(u)..." << endl;

        // Construct the dynamical-systems interface object depending on the given parameters.

        unique_ptr<cfDSI> dsi;
        dsi =
            unique_ptr<cfDSI>(new cfDSI(dnsflags, sigma, 0, dt, false, false, false, false, 0.0, LB)); // 0: poincarecondition
        
        VectorXd w1_vec;
        VectorXd lb_vec;
        field2vector(w1, w1_vec);
        field2vector(LB, lb_vec);
        FlowField uSum = w1;// + w1; // u = u_pert + u_base
        //int fcount2 = 1;
        NSE nse;

        // compute pressure for LB:
        FlowField q(LB.Nx(), LB.Ny(), LB.Nz(), 1, LB.Lx(), LB.Lz(), LB.a(), LB.b(), cfmpi);

        DNS dns({LB, q}, dnsflags);

        PressureSolver psolver(LB, dns.Ubase(), dns.Wbase(), dnsflags.nu, dnsflags.Vsuck, dnsflags.nonlinearity);
        psolver.solve(q, LB);
        vector<FlowField> fields = {LB, q};

        nse = NSE(fields, dnsflags);
        //MatrixXd A = dsi->jacobi(lb_vec, 1e-3, false, fcount2); // this Jacobian is taken around lb.

        unique_ptr<GMRES> gmres;
        int maxorder = 10;
        std::vector<FlowField> w_n_coeffs;
        w_n_coeffs.push_back(w1);
        std::cout << lambda << std::endl;
        std::cout << epsSolver << std::endl;
        std::cout << epsKrylov << std::endl;
        std::cout << NSolver << std::endl;
        ChebyCoeff Ubase = laminarProfile(dnsflags, LB.a(), LB.b(), LB.Ny());
        //LB+= Ubase;
        //FlowField ubase(Ubase);
        for (int order=2; order < maxorder; order++){
            // compute the RHS: 
            FlowField rhs(LB.Nx(), LB.Ny(), LB.Nz(), 3, LB.Lx(), LB.Lz(), LB.a(), LB.b());
            //rhs.makeSpectral();
            FlowField tmp(LB.Nx(), LB.Ny(), LB.Nz(), 3,LB.Lx(), LB.Lz(), LB.a(), LB.b());
            //tmp.makeSpectral();
            
            for(int j = 1; j< order; j++){
                int k = order - j; // j + k = order
                
                    FlowField rhs_temp(LB.Nx(), LB.Ny(), LB.Nz(), 3,LB.Lx(), LB.Lz(), LB.a(), LB.b());
                    rhs_temp.makeSpectral();
                    std::cout << "order: " << order << ", j: " << j << ", k: " << k << std::endl;
                    dotgrad( w_n_coeffs[j-1],  w_n_coeffs[k-1], rhs_temp, tmp); // (u \cdot \nabla) u
                    rhs += rhs_temp;   
            }
            FlowField Q(LB.Nx(), LB.Ny(), LB.Nz(), 1, LB.Lx(), LB.Lz(), LB.a(), LB.b());
            PoissonSolver poisson(Q);
            poisson.verify(Q, div(rhs));

            poisson.solve(Q, div(rhs));
            poisson.verify(Q, div(rhs));
            rhs-=grad(Q);

            VectorXd rhs_vector;
            field2vector(rhs, rhs_vector);
            VectorXd dxN(rhs_vector.size());
            setToZero(dxN);
            Real solverResidual = 0.01;
            //int fcount = 1;
            //double epsDx = 1e-3;
            FlowField w_n(LB.Nx(), LB.Ny(), LB.Nz(), 3, LB.Lx(), LB.Lz(), LB.a(), LB.b());
            w_n.makeSpectral(); 
            GMRES gmres;
            gmres = GMRES(rhs_vector, NSolver, epsKrylov);
            for (int n = 0; n < NSolver; ++n) {
                std::cout << "GMRES == " << n << ", " << flush;

                // Compute v = Ab in Arnoldi iteration terms, where b is Q.column(n)
                // In Navier-Stokes terms, the main quantity to compute is
                // DG dx = 1/e (G(u + e du, sigma + e dsigma, T + e dT) - G(u,sigma,T)) for e << 1
                VectorXd q = gmres.testVector();
                VectorXd temppp = lb_vec + q;
                FlowField tempp(LB.Nx(), LB.Ny(), LB.Nz(), 3, LB.Lx(), LB.Lz(), LB.a(), LB.b(), cfmpi);
                vector2field(temppp, tempp);
                std::cout << "nroms: " << L2Norm(tempp)<< std::endl;

                // Compute Df dx = 1/e (f(x+e*q) - f(x))
                //VectorXd Ax = dsi->Jacobian(lb_vec, q, lb_vec, epsDx, false, fcount); // this Jacobian is taken around lb.
                  // compute pressure for LB:
                FlowField q2(LB.Nx(), LB.Ny(), LB.Nz(), 1, LB.Lx(), LB.Lz(), LB.a(), LB.b(), cfmpi);
                psolver.solve(q2, tempp);
                //std::cout << "div: aaaa "<< std::endl;
                
                vector<FlowField> fields2 = {tempp, q2};
                FlowField AAA(LB.Nx(), LB.Ny(), LB.Nz(), 3, LB.Lx(), LB.Lz(), LB.a(), LB.b(), cfmpi);

                vector<FlowField> outfield = {AAA};
                nse.linear(fields2, outfield);
                VectorXd Ax;
                field2vector(outfield[0], Ax);
                Ax -= lambda*order*q; // LHS

                // // Enforce orthogonality conditions
                // // i.e. for e.g. xrel: Lq(xunk) = dG/dx dot q
                // VectorXd e(Nunk);
                // int tph = (msDSI_->tph()) ? 1 : 0;
                // for (int i = tph; i < Northog; ++i) {
                //     e = E.col(i);
                //     Real res = L2IP(q, e);  // L2IP(Lq,e)
                //     if (taskid == 0) {
                //         Lq(uunk + i) = res;
                //     }
                // }

                gmres.iterate(Ax);
                solverResidual = gmres.residual();
                std::cout << " res == " << solverResidual << endl;
    
                    std::cout << "div: " << L2Norm(div(rhs))<< std::endl;

                if (solverResidual < epsSolver) {
                    std::cout << "GMRES converged. Breaking." << endl;
                    dxN = gmres.solution();

                    vector2field(dxN, w_n);
                    std::cout << "div: " << L2Norm(div(w_n))<< std::endl;
                    std::string output = "w";
                    output += std::to_string(order);
                    w_n.save(output);
                    w_n_coeffs.push_back(w_n);
                    break;
                    //return 0;
                } 
                else if (n == NSolver - 1) {
                    std::cout << "GMRES failed to converge. Returning best answer so far." << endl;
                    dxN = gmres.solution();
                    break;
                    //return 0;
                }
            }  // end GMRES iteration
        }
        return 0;

        fftw_savewisdom();
    }
    cfMPI_Finalize();
}