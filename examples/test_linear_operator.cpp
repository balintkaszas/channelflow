/**
 * This file is a part of channelflow version 2.0 https://channelflow.ch.
 * License is GNU GPL version 2 or later: ./LICENCE
 */
#include <sys/stat.h>
#include <Eigen/Dense>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <string>
#include "cfbasics/cfvector.h"
#include "channelflow/cfdsi.h"
#include "channelflow/chebyshev.h"
#include "channelflow/dns.h"
#include "nsolver/gmres.h"
#include "channelflow/flowfield.h"
#include "channelflow/symmetry.h"
#include "channelflow/tausolver.h"
#include "nsolver/nsolver.h"
#include "channelflow/diffops.h" // because of readheteroclinicorbit

using namespace std;
using namespace Eigen;
using namespace chflow;

int main(int argc, char* argv[]) {
    cfMPI_Init(&argc, &argv);
    {
        WriteProcessInfo(argc, argv);
        int taskid = 0;
#ifdef HAVE_MPI
        MPI_Comm_rank(MPI_COMM_WORLD, &taskid);
#endif

        string purpose(
            "Solve the linear equation defining the second order term: (A-2lambda)x = (w_1 grad) w_1 ");
        ArgList args(argc, argv, purpose);

        DNSFlags dnsflags(args);
        TimeStep dt(dnsflags);
        dnsflags.verbosity = Silent;


        args.section("Program options");
        const string sigstr =
            args.getstr("-sigma", "--sigma", "", "file containing sigma of sigma f^T(u) - u = 0 (default == identity)");

        const int seed = args.getint("-sd", "--seed", 1, "seed for random number generator");
        const Real lambda = args.getreal("-lambda", "--lambda", 0, "Eigenvalue");
        const Real epsKrylov = args.getreal("-ek", "--epsKrylov", 1e-14, "minimum condition number of Krylov vectors");
        const Real epsSolver = args.getreal("-eg", "--epsSolver", 1e-3, "stop GMRES iteration when Ax = b residual is < epsSolver");

        const int nproc0 =
            args.getint("-np0", "--nproc0", 0, "number of MPI-processes for transpose/number of parallel ffts");
        const int nproc1 = args.getint("-np1", "--nproc1", 0, "number of MPI-processes for one fft");
        //const int length = args.getint("-nst", "--numsnapshots", 0, "number of snapshots along the heteroclinic orbit");
        //const int DTS = args.getint("-dst", "--distsnapshots", 0, "sampling rate of snapshots");

        const string source_in = args.getstr(1, "<src>", "eigenvector: w1");
        const string source_lb = args.getstr(2, "<src>", "LB ");
        const int NSolver = args.getint("-Ng", "--Ngmres", 500, "maximum number of GMRES iterations");

        //const string source_out = args.getstr(3, "<src2>", "Location of the output file");
        
        CfMPI* cfmpi = &CfMPI::getInstance(nproc0, nproc1);
        args.check();
        args.save("./");

        fftw_loadwisdom();

        srand48(seed);

        // read LB: 
        
        FlowField LB(source_lb, cfmpi);  // u*, the solution of sigma f^T(u*) - u* = 0
        FlowField w1(source_in, cfmpi); 

        const int Nx = LB.Nx();
        const int Ny = LB.Ny();
        const int Nz = LB.Nz();

        const int kxmin = -LB.kxmaxDealiased();
        const int kxmax = LB.kxmaxDealiased();
        const int kzmin = 0;
        const int kzmax = LB.kzmaxDealiased();

        if (taskid == 0) {
            cout << setprecision(17);
            cout << "   Nx == " << Nx << endl;
            cout << "   Ny == " << Ny << endl;
            cout << "   Nz == " << Nz << endl;
            cout << "kxmin == " << kxmin << endl;
            cout << "kxmax == " << kxmax << endl;
            cout << "kzmin == " << kzmin << endl;
            cout << "kzmax == " << kzmax << endl;

            cout << "dt     == " << dt.dt() << endl;
            cout << "dtmin  == " << dt.dtmin() << endl;
            cout << "dtmax  == " << dt.dtmax() << endl;
            cout << "CFLmin == " << dt.CFLmin() << endl;
            cout << "CFLmax == " << dt.CFLmax() << endl;
        }
        dt.adjust_for_T(dnsflags.T);

        FieldSymmetry sigma;  // defaults to identity
        if (sigstr.length() != 0)
            sigma = FieldSymmetry(sigstr);

        if (dnsflags.symmetries.length() > 0) {
            if (taskid == 0) {
                cout << "Restricting flow to invariant subspace generated by symmetries" << endl;
                cout << dnsflags.symmetries << endl;
            }
        }

        if (taskid == 0)
            cout << "DNS flags = " << dnsflags << endl;



        // Set up DNS operator ("A" in Arnoldi A*b terms)
        if (taskid == 0)
            cout << "setting up DNS and initial fields..." << endl;
        ChebyTransform trans(Ny);

        
        if (taskid == 0)
            cout << "computing sigma f^T(u)..." << endl;

        // Construct the dynamical-systems interface object depending on the given parameters.

        unique_ptr<cfDSI> dsi;
        dsi =
            unique_ptr<cfDSI>(new cfDSI(dnsflags, sigma, 0, dt, false, false, false, false, 0.0, LB)); // 0: poincarecondition
        
        VectorXd w1_vec;
        VectorXd lb_vec;
        field2vector(w1, w1_vec);
        field2vector(LB, lb_vec);
        FlowField uSum = w1;// + w1; // u = u_pert + u_base


        std::cout << lambda << std::endl;
        std::cout << epsSolver << std::endl;
        std::cout << epsKrylov << std::endl;
        std::cout << NSolver << std::endl;
        std::cout << dnsflags.T << std::endl;
        double epsDx = 1e-6;
        // Compute Df dx = 1/e (f(x+e*q) - f(x)) 
        // test if Df w_1 = \lambda w_1
        int fcount = 0;
        // Lambda = e^{lambda T}
        // Compute Df dx = 1/e (f(x+e*q) - f(x)) 
        // to get the time-derivative: g^T = (f^T - x0)/T
        // Compute Dg dx = 1/e (g(x+e*q) - g(x)) 
        Real explambda = exp(lambda * dnsflags.T);
        VectorXd plus = lb_vec + epsDx * w1_vec;
        VectorXd evaluated = dsi->eval(plus);
        evaluated += plus;
        VectorXd evaluated2 = dsi->eval(lb_vec);
        VectorXd Ax1 = (evaluated - lb_vec) / epsDx; // this is the jacobian of the flow


        VectorXd evaluated_derivative = dsi->eval(plus);
        VectorXd Ax_derivative =  (evaluated_derivative - evaluated2) / (dnsflags.T * epsDx );
        //std::cout << "Error_norm = " << L2Norm(err) << std::endl;
        std::cout << "explambda = " << explambda << std::endl;

        VectorXd Ax2 = dsi->Jacobian(lb_vec, w1_vec, lb_vec, epsDx, false, fcount); // this Jacobian is taken around lb.
        VectorXd lambda_w1 = explambda * w1_vec;
        VectorXd lambda_w1_deriv = lambda * w1_vec;

        VectorXd dax = Ax1 - lambda_w1;
        VectorXd dax_deriv = Ax_derivative - lambda_w1_deriv;

        std::cout << "error norm = " << L2Norm(dax) << std::endl;
        std::cout << "error norm deriv = " << L2Norm(dax_deriv) << std::endl;


        std::cout << "eval_norm = " << L2Norm(evaluated2) << std::endl;
        //VectorXd error = Ax - lambda_w1;
        //Real error_norm = L2Norm(error);

        std::cout << "Ax1 = " << L2Norm(Ax1) << std::endl;
        std::cout << "Ax2 = " << L2Norm(Ax2) << std::endl;

        std::cout << "w1 = " << L2Norm(w1_vec) << std::endl;
        
        //std::cout << "error norm = " << error_norm << std::endl;
        return 0;

        fftw_savewisdom();
    }
    cfMPI_Finalize();
}