/**
 * This file is a part of channelflow version 2.0 https://channelflow.ch.
 * License is GNU GPL version 2 or later: ./LICENCE
 */
#include <sys/stat.h>
#include <Eigen/Dense>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <string>
#include "cfbasics/cfvector.h"
#include "channelflow/cfdsi.h"
#include "channelflow/chebyshev.h"
#include "channelflow/dns.h"
#include "channelflow/flowfield.h"
#include "channelflow/symmetry.h"
#include "channelflow/tausolver.h"
#include "nsolver/nsolver.h"
#include "channelflow/diffops.h" // because of readheteroclinicorbit

using namespace std;
using namespace Eigen;
using namespace chflow;

int main(int argc, char* argv[]) {
    cfMPI_Init(&argc, &argv);
    {
        WriteProcessInfo(argc, argv);
        int taskid = 0;
#ifdef HAVE_MPI
        MPI_Comm_rank(MPI_COMM_WORLD, &taskid);
#endif

        string purpose(
            "compute spectrum of eigenvalues of equilibria, traveling waves, or periodic orbit using Arnoldi "
            "iteration");
        ArgList args(argc, argv, purpose);

        DNSFlags dnsflags(args);
        TimeStep dt(dnsflags);
        dnsflags.verbosity = Silent;

        // The Eigenvals class is utilized to solve the eigenvalue problem.
        // This class requires Arnoldi class.
        unique_ptr<Eigenvals> E;
        EigenvalsFlags eigenflags(args);
        E = unique_ptr<Eigenvals>(new Eigenvals(eigenflags));

        args.section("Program options");
        const string sigstr =
            args.getstr("-sigma", "--sigma", "", "file containing sigma of sigma f^T(u) - u = 0 (default == identity)");

        const int seed = args.getint("-sd", "--seed", 1, "seed for random number generator");
        const int nproc0 =
            args.getint("-np0", "--nproc0", 0, "number of MPI-processes for transpose/number of parallel ffts");
        const int nproc1 = args.getint("-np1", "--nproc1", 0, "number of MPI-processes for one fft");
        //const int length = args.getint("-nst", "--numsnapshots", 0, "number of snapshots along the heteroclinic orbit");
        //const int DTS = args.getint("-dst", "--distsnapshots", 0, "sampling rate of snapshots");

        const string source_in = args.getstr(1, "<src>", "Location of the heteroclinic orbit");

        const string source_out = args.getstr(2, "<src2>", "Location of the output files f(u)");
        
        CfMPI* cfmpi = &CfMPI::getInstance(nproc0, nproc1);

        args.check();
        args.save("./");
        args.save(eigenflags.outdir);

        fftw_loadwisdom();

        srand48(seed);

        /* Read the line of points along which to calculate derivative */

        // read the orbit: 
        // std::string source = "../exactHeteroclinic/LBtoLam/";
        std::vector<FlowField> UC = readHeteroclinicOrbit(source_in + "u", 0, 1500, 1);
        // use the first entry in the heteroclinic orbit for u:
        FlowField u(source_in + "u0", cfmpi);  // u*, the solution of sigma f^T(u*) - u* = 0
        

        const int Nx = u.Nx();
        const int Ny = u.Ny();
        const int Nz = u.Nz();

        const int kxmin = -u.kxmaxDealiased();
        const int kxmax = u.kxmaxDealiased();
        const int kzmin = 0;
        const int kzmax = u.kzmaxDealiased();

        if (taskid == 0) {
            cout << setprecision(17);
            cout << "   Nx == " << Nx << endl;
            cout << "   Ny == " << Ny << endl;
            cout << "   Nz == " << Nz << endl;
            cout << "kxmin == " << kxmin << endl;
            cout << "kxmax == " << kxmax << endl;
            cout << "kzmin == " << kzmin << endl;
            cout << "kzmax == " << kzmax << endl;

            cout << "dt     == " << dt.dt() << endl;
            cout << "dtmin  == " << dt.dtmin() << endl;
            cout << "dtmax  == " << dt.dtmax() << endl;
            cout << "CFLmin == " << dt.CFLmin() << endl;
            cout << "CFLmax == " << dt.CFLmax() << endl;
        }
        dt.adjust_for_T(dnsflags.T);

        FieldSymmetry sigma;  // defaults to identity
        if (sigstr.length() != 0)
            sigma = FieldSymmetry(sigstr);

        if (dnsflags.symmetries.length() > 0) {
            if (taskid == 0) {
                cout << "Restricting flow to invariant subspace generated by symmetries" << endl;
                cout << dnsflags.symmetries << endl;
            }
        }

        if (taskid == 0)
            cout << "DNS flags = " << dnsflags << endl;
        dnsflags.save(eigenflags.outdir);



        // Set up DNS operator ("A" in Arnoldi A*b terms)
        if (taskid == 0)
            cout << "setting up DNS and initial fields..." << endl;
        ChebyTransform trans(Ny);

        
        FlowField Gu(u);
        if (taskid == 0)
            cout << "computing sigma f^T(u)..." << endl;

        // Construct the dynamical-systems interface object depending on the given parameters.

        unique_ptr<cfDSI> dsi;
        dsi =
            unique_ptr<cfDSI>(new cfDSI(dnsflags, sigma, 0, dt, false, false, false, false, 0.0, u, E->getLogstream())); // 0: poincarecondition


        // loop over the heteroclinic orbit
        for(int i =0; i<UC.size(); i++){
            FlowField uelement = UC[i];
            VectorXd x;
            field2vector(uelement, x);
            VectorXd Gx = dsi->eval(x) / dnsflags.T; // Divide by the Time interval: fprime \approx (f^T(u) - u)/T
            const string filebase = "eval" + std::to_string(i);
            dsi->save(Gx, filebase, source_out, true); // true-> write fields only
        }
        


        fftw_savewisdom();
    }
    cfMPI_Finalize();
}